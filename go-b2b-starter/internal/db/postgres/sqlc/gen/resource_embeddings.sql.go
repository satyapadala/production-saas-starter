// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: resource_embeddings.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const confirmDuplicate = `-- name: ConfirmDuplicate :exec
UPDATE duplicate_candidates
SET status = 'confirmed', updated_at = NOW()
WHERE id = $1
`

// Marks a duplicate candidate as confirmed
func (q *Queries) ConfirmDuplicate(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, confirmDuplicate, id)
	return err
}

const countDuplicatesByStatus = `-- name: CountDuplicatesByStatus :one
SELECT COUNT(*) FROM duplicate_candidates
WHERE organization_id = $1 AND status = $2
`

type CountDuplicatesByStatusParams struct {
	OrganizationID int32       `json:"organization_id"`
	Status         pgtype.Text `json:"status"`
}

// Counts duplicate candidates by status for an organization
func (q *Queries) CountDuplicatesByStatus(ctx context.Context, arg CountDuplicatesByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDuplicatesByStatus, arg.OrganizationID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEmbeddingsByOrganization = `-- name: CountEmbeddingsByOrganization :one
SELECT COUNT(*) FROM resource_embeddings
WHERE organization_id = $1
`

// Counts total embeddings for an organization
func (q *Queries) CountEmbeddingsByOrganization(ctx context.Context, organizationID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countEmbeddingsByOrganization, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDuplicateCandidateExactMatch = `-- name: CreateDuplicateCandidateExactMatch :one
INSERT INTO duplicate_candidates (
    resource_id,
    candidate_resource_id,
    similarity_score,
    detection_method,
    confidence_level,
    organization_id,
    status
) VALUES (
    $1, $2, $3, 'exact_match', 'very_high', $4, 'pending'
) RETURNING id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at
`

type CreateDuplicateCandidateExactMatchParams struct {
	ResourceID          int32          `json:"resource_id"`
	CandidateResourceID int32          `json:"candidate_resource_id"`
	SimilarityScore     pgtype.Numeric `json:"similarity_score"`
	OrganizationID      int32          `json:"organization_id"`
}

// Creates a duplicate candidate for exact/perfect matches (no LLM data)
func (q *Queries) CreateDuplicateCandidateExactMatch(ctx context.Context, arg CreateDuplicateCandidateExactMatchParams) (DuplicateCandidate, error) {
	row := q.db.QueryRow(ctx, createDuplicateCandidateExactMatch,
		arg.ResourceID,
		arg.CandidateResourceID,
		arg.SimilarityScore,
		arg.OrganizationID,
	)
	var i DuplicateCandidate
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.CandidateResourceID,
		&i.SimilarityScore,
		&i.DetectionMethod,
		&i.ConfidenceLevel,
		&i.LlmReason,
		&i.LlmSimilarFields,
		&i.LlmResponse,
		&i.OrganizationID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDuplicateCandidateLLM = `-- name: CreateDuplicateCandidateLLM :one
INSERT INTO duplicate_candidates (
    resource_id,
    candidate_resource_id,
    similarity_score,
    detection_method,
    confidence_level,
    llm_reason,
    llm_similar_fields,
    llm_response,
    organization_id,
    status
) VALUES (
    $1, $2, $3, 'llm_adjudicated', $4, $5, $6, $7, $8, 'pending'
) RETURNING id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at
`

type CreateDuplicateCandidateLLMParams struct {
	ResourceID          int32          `json:"resource_id"`
	CandidateResourceID int32          `json:"candidate_resource_id"`
	SimilarityScore     pgtype.Numeric `json:"similarity_score"`
	ConfidenceLevel     pgtype.Text    `json:"confidence_level"`
	LlmReason           pgtype.Text    `json:"llm_reason"`
	LlmSimilarFields    []byte         `json:"llm_similar_fields"`
	LlmResponse         []byte         `json:"llm_response"`
	OrganizationID      int32          `json:"organization_id"`
}

// Creates a duplicate candidate with LLM adjudication data
func (q *Queries) CreateDuplicateCandidateLLM(ctx context.Context, arg CreateDuplicateCandidateLLMParams) (DuplicateCandidate, error) {
	row := q.db.QueryRow(ctx, createDuplicateCandidateLLM,
		arg.ResourceID,
		arg.CandidateResourceID,
		arg.SimilarityScore,
		arg.ConfidenceLevel,
		arg.LlmReason,
		arg.LlmSimilarFields,
		arg.LlmResponse,
		arg.OrganizationID,
	)
	var i DuplicateCandidate
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.CandidateResourceID,
		&i.SimilarityScore,
		&i.DetectionMethod,
		&i.ConfidenceLevel,
		&i.LlmReason,
		&i.LlmSimilarFields,
		&i.LlmResponse,
		&i.OrganizationID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createResourceDuplicateCandidate = `-- name: CreateResourceDuplicateCandidate :one

INSERT INTO duplicate_candidates (
    resource_id,
    candidate_resource_id,
    similarity_score,
    detection_method,
    confidence_level,
    llm_reason,
    llm_similar_fields,
    llm_response,
    organization_id,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at
`

type CreateResourceDuplicateCandidateParams struct {
	ResourceID          int32          `json:"resource_id"`
	CandidateResourceID int32          `json:"candidate_resource_id"`
	SimilarityScore     pgtype.Numeric `json:"similarity_score"`
	DetectionMethod     string         `json:"detection_method"`
	ConfidenceLevel     pgtype.Text    `json:"confidence_level"`
	LlmReason           pgtype.Text    `json:"llm_reason"`
	LlmSimilarFields    []byte         `json:"llm_similar_fields"`
	LlmResponse         []byte         `json:"llm_response"`
	OrganizationID      int32          `json:"organization_id"`
	Status              pgtype.Text    `json:"status"`
}

// Duplicate Candidates Queries
// Creates a new duplicate candidate record
func (q *Queries) CreateResourceDuplicateCandidate(ctx context.Context, arg CreateResourceDuplicateCandidateParams) (DuplicateCandidate, error) {
	row := q.db.QueryRow(ctx, createResourceDuplicateCandidate,
		arg.ResourceID,
		arg.CandidateResourceID,
		arg.SimilarityScore,
		arg.DetectionMethod,
		arg.ConfidenceLevel,
		arg.LlmReason,
		arg.LlmSimilarFields,
		arg.LlmResponse,
		arg.OrganizationID,
		arg.Status,
	)
	var i DuplicateCandidate
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.CandidateResourceID,
		&i.SimilarityScore,
		&i.DetectionMethod,
		&i.ConfidenceLevel,
		&i.LlmReason,
		&i.LlmSimilarFields,
		&i.LlmResponse,
		&i.OrganizationID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDuplicateCandidate = `-- name: DeleteDuplicateCandidate :exec
DELETE FROM duplicate_candidates
WHERE id = $1
`

// Deletes a duplicate candidate record
func (q *Queries) DeleteDuplicateCandidate(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDuplicateCandidate, id)
	return err
}

const deleteResourceEmbedding = `-- name: DeleteResourceEmbedding :exec

DELETE FROM resource_embeddings
WHERE resource_id = $1 AND organization_id = $2
`

type DeleteResourceEmbeddingParams struct {
	ResourceID     int32 `json:"resource_id"`
	OrganizationID int32 `json:"organization_id"`
}

// Exclude the current resource
// Deletes an embedding for a resource
func (q *Queries) DeleteResourceEmbedding(ctx context.Context, arg DeleteResourceEmbeddingParams) error {
	_, err := q.db.Exec(ctx, deleteResourceEmbedding, arg.ResourceID, arg.OrganizationID)
	return err
}

const dismissDuplicate = `-- name: DismissDuplicate :exec
UPDATE duplicate_candidates
SET status = 'dismissed', updated_at = NOW()
WHERE id = $1
`

// Marks a duplicate candidate as dismissed
func (q *Queries) DismissDuplicate(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, dismissDuplicate, id)
	return err
}

const findExactDuplicateByHash = `-- name: FindExactDuplicateByHash :many
SELECT
    resource_id,
    content_hash,
    content_preview
FROM resource_embeddings
WHERE organization_id = $1
    AND content_hash = $2
    AND resource_id != $3
`

type FindExactDuplicateByHashParams struct {
	OrganizationID int32       `json:"organization_id"`
	ContentHash    pgtype.Text `json:"content_hash"`
	ResourceID     int32       `json:"resource_id"`
}

type FindExactDuplicateByHashRow struct {
	ResourceID     int32       `json:"resource_id"`
	ContentHash    pgtype.Text `json:"content_hash"`
	ContentPreview pgtype.Text `json:"content_preview"`
}

// Finds exact duplicates using content hash (faster than vector search for exact matches)
func (q *Queries) FindExactDuplicateByHash(ctx context.Context, arg FindExactDuplicateByHashParams) ([]FindExactDuplicateByHashRow, error) {
	rows, err := q.db.Query(ctx, findExactDuplicateByHash, arg.OrganizationID, arg.ContentHash, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindExactDuplicateByHashRow{}
	for rows.Next() {
		var i FindExactDuplicateByHashRow
		if err := rows.Scan(&i.ResourceID, &i.ContentHash, &i.ContentPreview); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSimilarResources = `-- name: FindSimilarResources :many
SELECT
    resource_id,
    1 - (embedding <=> $1::vector) AS similarity_score,
    content_hash,
    content_preview
FROM resource_embeddings
WHERE organization_id = $2
    AND resource_id != $3
    AND 1 - (embedding <=> $1::vector) >= $4
ORDER BY embedding <=> $1::vector -- Order by distance (closest first)
LIMIT $5
`

type FindSimilarResourcesParams struct {
	Column1        pgvector_go.Vector `json:"column_1"`
	OrganizationID int32              `json:"organization_id"`
	ResourceID     int32              `json:"resource_id"`
	Embedding      pgvector_go.Vector `json:"embedding"`
	Limit          int32              `json:"limit"`
}

type FindSimilarResourcesRow struct {
	ResourceID      int32       `json:"resource_id"`
	SimilarityScore int32       `json:"similarity_score"`
	ContentHash     pgtype.Text `json:"content_hash"`
	ContentPreview  pgtype.Text `json:"content_preview"`
}

// Finds similar resources using vector cosine similarity search
// The <=> operator calculates cosine distance (0 = identical, 2 = opposite)
// We convert to similarity score: 1 - distance/2 = similarity (0 to 1)
//
// Parameters:
// $1: embedding vector to search for
// $2: organization_id to scope the search
// $3: resource_id to exclude (don't match against itself)
// $4: minimum similarity threshold (e.g., 0.85)
// $5: limit on number of results
func (q *Queries) FindSimilarResources(ctx context.Context, arg FindSimilarResourcesParams) ([]FindSimilarResourcesRow, error) {
	rows, err := q.db.Query(ctx, findSimilarResources,
		arg.Column1,
		arg.OrganizationID,
		arg.ResourceID,
		arg.Embedding,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSimilarResourcesRow{}
	for rows.Next() {
		var i FindSimilarResourcesRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.SimilarityScore,
			&i.ContentHash,
			&i.ContentPreview,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDuplicateCandidate = `-- name: GetDuplicateCandidate :one
SELECT id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at FROM duplicate_candidates
WHERE id = $1
`

// Gets a specific duplicate candidate by ID
func (q *Queries) GetDuplicateCandidate(ctx context.Context, id int32) (DuplicateCandidate, error) {
	row := q.db.QueryRow(ctx, getDuplicateCandidate, id)
	var i DuplicateCandidate
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.CandidateResourceID,
		&i.SimilarityScore,
		&i.DetectionMethod,
		&i.ConfidenceLevel,
		&i.LlmReason,
		&i.LlmSimilarFields,
		&i.LlmResponse,
		&i.OrganizationID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceDuplicateStats = `-- name: GetResourceDuplicateStats :one
SELECT
    COUNT(*) as total_candidates,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'confirmed') as confirmed_count,
    COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed_count,
    COUNT(*) FILTER (WHERE detection_method = 'exact_match') as exact_match_count,
    COUNT(*) FILTER (WHERE detection_method = 'llm_adjudicated') as llm_adjudicated_count,
    AVG(similarity_score) as avg_similarity_score
FROM duplicate_candidates
WHERE organization_id = $1
`

type GetResourceDuplicateStatsRow struct {
	TotalCandidates     int64   `json:"total_candidates"`
	PendingCount        int64   `json:"pending_count"`
	ConfirmedCount      int64   `json:"confirmed_count"`
	DismissedCount      int64   `json:"dismissed_count"`
	ExactMatchCount     int64   `json:"exact_match_count"`
	LlmAdjudicatedCount int64   `json:"llm_adjudicated_count"`
	AvgSimilarityScore  float64 `json:"avg_similarity_score"`
}

// Gets statistics about duplicate detection for an organization
func (q *Queries) GetResourceDuplicateStats(ctx context.Context, organizationID int32) (GetResourceDuplicateStatsRow, error) {
	row := q.db.QueryRow(ctx, getResourceDuplicateStats, organizationID)
	var i GetResourceDuplicateStatsRow
	err := row.Scan(
		&i.TotalCandidates,
		&i.PendingCount,
		&i.ConfirmedCount,
		&i.DismissedCount,
		&i.ExactMatchCount,
		&i.LlmAdjudicatedCount,
		&i.AvgSimilarityScore,
	)
	return i, err
}

const getResourceEmbedding = `-- name: GetResourceEmbedding :one
SELECT id, resource_id, embedding, organization_id, content_hash, content_preview, created_at, updated_at FROM resource_embeddings
WHERE resource_id = $1 AND organization_id = $2
LIMIT 1
`

type GetResourceEmbeddingParams struct {
	ResourceID     int32 `json:"resource_id"`
	OrganizationID int32 `json:"organization_id"`
}

// Retrieves the embedding for a specific resource
func (q *Queries) GetResourceEmbedding(ctx context.Context, arg GetResourceEmbeddingParams) (ResourceEmbedding, error) {
	row := q.db.QueryRow(ctx, getResourceEmbedding, arg.ResourceID, arg.OrganizationID)
	var i ResourceEmbedding
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.Embedding,
		&i.OrganizationID,
		&i.ContentHash,
		&i.ContentPreview,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDuplicateCandidatesForResource = `-- name: ListDuplicateCandidatesForResource :many
SELECT id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at FROM duplicate_candidates
WHERE resource_id = $1 AND organization_id = $2
ORDER BY similarity_score DESC, created_at DESC
`

type ListDuplicateCandidatesForResourceParams struct {
	ResourceID     int32 `json:"resource_id"`
	OrganizationID int32 `json:"organization_id"`
}

// Lists all duplicate candidates for a specific resource
func (q *Queries) ListDuplicateCandidatesForResource(ctx context.Context, arg ListDuplicateCandidatesForResourceParams) ([]DuplicateCandidate, error) {
	rows, err := q.db.Query(ctx, listDuplicateCandidatesForResource, arg.ResourceID, arg.OrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DuplicateCandidate{}
	for rows.Next() {
		var i DuplicateCandidate
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.CandidateResourceID,
			&i.SimilarityScore,
			&i.DetectionMethod,
			&i.ConfidenceLevel,
			&i.LlmReason,
			&i.LlmSimilarFields,
			&i.LlmResponse,
			&i.OrganizationID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDuplicates = `-- name: ListPendingDuplicates :many
SELECT id, resource_id, candidate_resource_id, similarity_score, detection_method, confidence_level, llm_reason, llm_similar_fields, llm_response, organization_id, status, created_at, updated_at FROM duplicate_candidates
WHERE organization_id = $1 AND status = 'pending'
ORDER BY similarity_score DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListPendingDuplicatesParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

// Lists all pending duplicate candidates for an organization
func (q *Queries) ListPendingDuplicates(ctx context.Context, arg ListPendingDuplicatesParams) ([]DuplicateCandidate, error) {
	rows, err := q.db.Query(ctx, listPendingDuplicates, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DuplicateCandidate{}
	for rows.Next() {
		var i DuplicateCandidate
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.CandidateResourceID,
			&i.SimilarityScore,
			&i.DetectionMethod,
			&i.ConfidenceLevel,
			&i.LlmReason,
			&i.LlmSimilarFields,
			&i.LlmResponse,
			&i.OrganizationID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveResourceEmbedding = `-- name: SaveResourceEmbedding :exec

INSERT INTO resource_embeddings (
    resource_id,
    embedding,
    organization_id,
    content_hash,
    content_preview
) VALUES (
    $1, $2, $3, $4, $5
) ON CONFLICT (resource_id, organization_id)
DO UPDATE SET
    embedding = EXCLUDED.embedding,
    content_hash = EXCLUDED.content_hash,
    content_preview = EXCLUDED.content_preview,
    updated_at = NOW()
`

type SaveResourceEmbeddingParams struct {
	ResourceID     int32              `json:"resource_id"`
	Embedding      pgvector_go.Vector `json:"embedding"`
	OrganizationID int32              `json:"organization_id"`
	ContentHash    pgtype.Text        `json:"content_hash"`
	ContentPreview pgtype.Text        `json:"content_preview"`
}

// Resource Embeddings Queries
// These queries demonstrate pgvector usage for semantic similarity search
// Saves or updates an embedding for a resource
// Uses ON CONFLICT to handle duplicate resource_id + organization_id pairs
func (q *Queries) SaveResourceEmbedding(ctx context.Context, arg SaveResourceEmbeddingParams) error {
	_, err := q.db.Exec(ctx, saveResourceEmbedding,
		arg.ResourceID,
		arg.Embedding,
		arg.OrganizationID,
		arg.ContentHash,
		arg.ContentPreview,
	)
	return err
}

const updateDuplicateCandidateStatus = `-- name: UpdateDuplicateCandidateStatus :exec
UPDATE duplicate_candidates
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateDuplicateCandidateStatusParams struct {
	ID     int32       `json:"id"`
	Status pgtype.Text `json:"status"`
}

// Updates the status of a duplicate candidate
func (q *Queries) UpdateDuplicateCandidateStatus(ctx context.Context, arg UpdateDuplicateCandidateStatusParams) error {
	_, err := q.db.Exec(ctx, updateDuplicateCandidateStatus, arg.ID, arg.Status)
	return err
}
