// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: example_resource.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignResourceApproval = `-- name: AssignResourceApproval :exec
UPDATE example_resources SET
    approval_assigned_to_id = $3,
    approval_status = 'pending',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND organization_id = $2 AND is_active = true
`

type AssignResourceApprovalParams struct {
	ID                   int32       `json:"id"`
	OrganizationID       int32       `json:"organization_id"`
	ApprovalAssignedToID pgtype.Int4 `json:"approval_assigned_to_id"`
}

// Assign resource to someone for approval
func (q *Queries) AssignResourceApproval(ctx context.Context, arg AssignResourceApprovalParams) error {
	_, err := q.db.Exec(ctx, assignResourceApproval, arg.ID, arg.OrganizationID, arg.ApprovalAssignedToID)
	return err
}

const attachFileToResource = `-- name: AttachFileToResource :exec
UPDATE example_resources SET
    file_id = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND organization_id = $2 AND is_active = true
`

type AttachFileToResourceParams struct {
	ID             int32       `json:"id"`
	OrganizationID int32       `json:"organization_id"`
	FileID         pgtype.Int4 `json:"file_id"`
}

// Attach a file to a resource
func (q *Queries) AttachFileToResource(ctx context.Context, arg AttachFileToResourceParams) error {
	_, err := q.db.Exec(ctx, attachFileToResource, arg.ID, arg.OrganizationID, arg.FileID)
	return err
}

const countResources = `-- name: CountResources :one
SELECT COUNT(*) FROM example_resources
WHERE organization_id = $1 AND is_active = true
    AND ($2::smallint IS NULL OR status_id = $2)
    AND ($3::varchar IS NULL OR approval_status = $3)
    AND ($4::text IS NULL OR title ILIKE '%' || $4 || '%' OR description ILIKE '%' || $4 || '%')
`

type CountResourcesParams struct {
	OrganizationID int32  `json:"organization_id"`
	Column2        int16  `json:"column_2"`
	Column3        string `json:"column_3"`
	Column4        string `json:"column_4"`
}

// Count resources for pagination
func (q *Queries) CountResources(ctx context.Context, arg CountResourcesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResources,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMinimalResource = `-- name: CreateMinimalResource :one
INSERT INTO example_resources (
    resource_number, title, organization_id, created_by_account_id, status_id
) VALUES (
    $1, $2, $3, $4, 1
) RETURNING id, resource_number, title, description, status_id, file_id, extracted_data, processed_data, confidence, organization_id, created_by_account_id, approval_status, approval_assigned_to_id, approval_action_taker_id, approval_notes, metadata, is_active, created_at, updated_at
`

type CreateMinimalResourceParams struct {
	ResourceNumber     string      `json:"resource_number"`
	Title              string      `json:"title"`
	OrganizationID     int32       `json:"organization_id"`
	CreatedByAccountID pgtype.Int4 `json:"created_by_account_id"`
}

// Creates a minimal placeholder resource
func (q *Queries) CreateMinimalResource(ctx context.Context, arg CreateMinimalResourceParams) (ExampleResource, error) {
	row := q.db.QueryRow(ctx, createMinimalResource,
		arg.ResourceNumber,
		arg.Title,
		arg.OrganizationID,
		arg.CreatedByAccountID,
	)
	var i ExampleResource
	err := row.Scan(
		&i.ID,
		&i.ResourceNumber,
		&i.Title,
		&i.Description,
		&i.StatusID,
		&i.FileID,
		&i.ExtractedData,
		&i.ProcessedData,
		&i.Confidence,
		&i.OrganizationID,
		&i.CreatedByAccountID,
		&i.ApprovalStatus,
		&i.ApprovalAssignedToID,
		&i.ApprovalActionTakerID,
		&i.ApprovalNotes,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createResource = `-- name: CreateResource :one


INSERT INTO example_resources (
    resource_number, title, description, status_id, file_id,
    extracted_data, processed_data, confidence,
    organization_id, created_by_account_id, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, resource_number, title, description, status_id, file_id, extracted_data, processed_data, confidence, organization_id, created_by_account_id, approval_status, approval_assigned_to_id, approval_action_taker_id, approval_notes, metadata, is_active, created_at, updated_at
`

type CreateResourceParams struct {
	ResourceNumber     string         `json:"resource_number"`
	Title              string         `json:"title"`
	Description        pgtype.Text    `json:"description"`
	StatusID           int16          `json:"status_id"`
	FileID             pgtype.Int4    `json:"file_id"`
	ExtractedData      []byte         `json:"extracted_data"`
	ProcessedData      []byte         `json:"processed_data"`
	Confidence         pgtype.Numeric `json:"confidence"`
	OrganizationID     int32          `json:"organization_id"`
	CreatedByAccountID pgtype.Int4    `json:"created_by_account_id"`
	Metadata           []byte         `json:"metadata"`
}

// Example Resource Queries
// Demonstrates Clean Architecture patterns with CRUD operations,
// file attachments, OCR/LLM processing, and approval workflows
// CREATE operations
func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (ExampleResource, error) {
	row := q.db.QueryRow(ctx, createResource,
		arg.ResourceNumber,
		arg.Title,
		arg.Description,
		arg.StatusID,
		arg.FileID,
		arg.ExtractedData,
		arg.ProcessedData,
		arg.Confidence,
		arg.OrganizationID,
		arg.CreatedByAccountID,
		arg.Metadata,
	)
	var i ExampleResource
	err := row.Scan(
		&i.ID,
		&i.ResourceNumber,
		&i.Title,
		&i.Description,
		&i.StatusID,
		&i.FileID,
		&i.ExtractedData,
		&i.ProcessedData,
		&i.Confidence,
		&i.OrganizationID,
		&i.CreatedByAccountID,
		&i.ApprovalStatus,
		&i.ApprovalAssignedToID,
		&i.ApprovalActionTakerID,
		&i.ApprovalNotes,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :exec

UPDATE example_resources SET
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND organization_id = $2
`

type DeleteResourceParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
}

// DELETE operations
// Soft delete a resource
func (q *Queries) DeleteResource(ctx context.Context, arg DeleteResourceParams) error {
	_, err := q.db.Exec(ctx, deleteResource, arg.ID, arg.OrganizationID)
	return err
}

const getRecentResources = `-- name: GetRecentResources :many
SELECT
    id, resource_number, title, status_id, confidence,
    created_by_account_id, created_at
FROM example_resources
WHERE organization_id = $1 AND is_active = true
ORDER BY created_at DESC
LIMIT $2
`

type GetRecentResourcesParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
}

type GetRecentResourcesRow struct {
	ID                 int32            `json:"id"`
	ResourceNumber     string           `json:"resource_number"`
	Title              string           `json:"title"`
	StatusID           int16            `json:"status_id"`
	Confidence         pgtype.Numeric   `json:"confidence"`
	CreatedByAccountID pgtype.Int4      `json:"created_by_account_id"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
}

// Get most recently created resources
func (q *Queries) GetRecentResources(ctx context.Context, arg GetRecentResourcesParams) ([]GetRecentResourcesRow, error) {
	rows, err := q.db.Query(ctx, getRecentResources, arg.OrganizationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentResourcesRow{}
	for rows.Next() {
		var i GetRecentResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNumber,
			&i.Title,
			&i.StatusID,
			&i.Confidence,
			&i.CreatedByAccountID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceByID = `-- name: GetResourceByID :one

SELECT id, resource_number, title, description, status_id, file_id, extracted_data, processed_data, confidence, organization_id, created_by_account_id, approval_status, approval_assigned_to_id, approval_action_taker_id, approval_notes, metadata, is_active, created_at, updated_at FROM example_resources
WHERE id = $1 AND organization_id = $2 AND is_active = true
`

type GetResourceByIDParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
}

// READ operations
func (q *Queries) GetResourceByID(ctx context.Context, arg GetResourceByIDParams) (ExampleResource, error) {
	row := q.db.QueryRow(ctx, getResourceByID, arg.ID, arg.OrganizationID)
	var i ExampleResource
	err := row.Scan(
		&i.ID,
		&i.ResourceNumber,
		&i.Title,
		&i.Description,
		&i.StatusID,
		&i.FileID,
		&i.ExtractedData,
		&i.ProcessedData,
		&i.Confidence,
		&i.OrganizationID,
		&i.CreatedByAccountID,
		&i.ApprovalStatus,
		&i.ApprovalAssignedToID,
		&i.ApprovalActionTakerID,
		&i.ApprovalNotes,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceByNumber = `-- name: GetResourceByNumber :one
SELECT id, resource_number, title, description, status_id, file_id, extracted_data, processed_data, confidence, organization_id, created_by_account_id, approval_status, approval_assigned_to_id, approval_action_taker_id, approval_notes, metadata, is_active, created_at, updated_at FROM example_resources
WHERE resource_number = $1 AND organization_id = $2 AND is_active = true
`

type GetResourceByNumberParams struct {
	ResourceNumber string `json:"resource_number"`
	OrganizationID int32  `json:"organization_id"`
}

func (q *Queries) GetResourceByNumber(ctx context.Context, arg GetResourceByNumberParams) (ExampleResource, error) {
	row := q.db.QueryRow(ctx, getResourceByNumber, arg.ResourceNumber, arg.OrganizationID)
	var i ExampleResource
	err := row.Scan(
		&i.ID,
		&i.ResourceNumber,
		&i.Title,
		&i.Description,
		&i.StatusID,
		&i.FileID,
		&i.ExtractedData,
		&i.ProcessedData,
		&i.Confidence,
		&i.OrganizationID,
		&i.CreatedByAccountID,
		&i.ApprovalStatus,
		&i.ApprovalAssignedToID,
		&i.ApprovalActionTakerID,
		&i.ApprovalNotes,
		&i.Metadata,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceStats = `-- name: GetResourceStats :one

SELECT
    COUNT(*) as total_resources,
    COUNT(*) FILTER (WHERE status_id = 1) as draft_count,
    COUNT(*) FILTER (WHERE status_id = 2) as processing_count,
    COUNT(*) FILTER (WHERE status_id = 3) as completed_count,
    COUNT(*) FILTER (WHERE approval_status = 'pending') as pending_approval,
    COUNT(*) FILTER (WHERE approval_status = 'approved') as approved_count,
    AVG(confidence) as avg_confidence
FROM example_resources
WHERE organization_id = $1 AND is_active = true
`

type GetResourceStatsRow struct {
	TotalResources  int64   `json:"total_resources"`
	DraftCount      int64   `json:"draft_count"`
	ProcessingCount int64   `json:"processing_count"`
	CompletedCount  int64   `json:"completed_count"`
	PendingApproval int64   `json:"pending_approval"`
	ApprovedCount   int64   `json:"approved_count"`
	AvgConfidence   float64 `json:"avg_confidence"`
}

// ANALYTICS queries
// Get statistics for dashboard
func (q *Queries) GetResourceStats(ctx context.Context, organizationID int32) (GetResourceStatsRow, error) {
	row := q.db.QueryRow(ctx, getResourceStats, organizationID)
	var i GetResourceStatsRow
	err := row.Scan(
		&i.TotalResources,
		&i.DraftCount,
		&i.ProcessingCount,
		&i.CompletedCount,
		&i.PendingApproval,
		&i.ApprovedCount,
		&i.AvgConfidence,
	)
	return i, err
}

const getResourcesByCreator = `-- name: GetResourcesByCreator :many
SELECT id, resource_number, title, description, status_id, file_id, extracted_data, processed_data, confidence, organization_id, created_by_account_id, approval_status, approval_assigned_to_id, approval_action_taker_id, approval_notes, metadata, is_active, created_at, updated_at FROM example_resources
WHERE organization_id = $1
    AND created_by_account_id = $2
    AND is_active = true
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetResourcesByCreatorParams struct {
	OrganizationID     int32       `json:"organization_id"`
	CreatedByAccountID pgtype.Int4 `json:"created_by_account_id"`
	Limit              int32       `json:"limit"`
	Offset             int32       `json:"offset"`
}

// Get resources created by a specific user
func (q *Queries) GetResourcesByCreator(ctx context.Context, arg GetResourcesByCreatorParams) ([]ExampleResource, error) {
	rows, err := q.db.Query(ctx, getResourcesByCreator,
		arg.OrganizationID,
		arg.CreatedByAccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleResource{}
	for rows.Next() {
		var i ExampleResource
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNumber,
			&i.Title,
			&i.Description,
			&i.StatusID,
			&i.FileID,
			&i.ExtractedData,
			&i.ProcessedData,
			&i.Confidence,
			&i.OrganizationID,
			&i.CreatedByAccountID,
			&i.ApprovalStatus,
			&i.ApprovalAssignedToID,
			&i.ApprovalActionTakerID,
			&i.ApprovalNotes,
			&i.Metadata,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteResource = `-- name: HardDeleteResource :exec
DELETE FROM example_resources
WHERE id = $1 AND organization_id = $2
`

type HardDeleteResourceParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
}

// Hard delete a resource (use with caution)
func (q *Queries) HardDeleteResource(ctx context.Context, arg HardDeleteResourceParams) error {
	_, err := q.db.Exec(ctx, hardDeleteResource, arg.ID, arg.OrganizationID)
	return err
}

const listResources = `-- name: ListResources :many
SELECT
    id, resource_number, title, description, status_id, file_id,
    confidence, organization_id, created_by_account_id,
    approval_status, approval_assigned_to_id,
    is_active, created_at, updated_at
FROM example_resources
WHERE organization_id = $1 AND is_active = true
    AND ($2::smallint IS NULL OR status_id = $2)
    AND ($3::varchar IS NULL OR approval_status = $3)
    AND ($4::text IS NULL OR title ILIKE '%' || $4 || '%' OR description ILIKE '%' || $4 || '%')
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListResourcesParams struct {
	OrganizationID int32  `json:"organization_id"`
	Column2        int16  `json:"column_2"`
	Column3        string `json:"column_3"`
	Column4        string `json:"column_4"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type ListResourcesRow struct {
	ID                   int32            `json:"id"`
	ResourceNumber       string           `json:"resource_number"`
	Title                string           `json:"title"`
	Description          pgtype.Text      `json:"description"`
	StatusID             int16            `json:"status_id"`
	FileID               pgtype.Int4      `json:"file_id"`
	Confidence           pgtype.Numeric   `json:"confidence"`
	OrganizationID       int32            `json:"organization_id"`
	CreatedByAccountID   pgtype.Int4      `json:"created_by_account_id"`
	ApprovalStatus       pgtype.Text      `json:"approval_status"`
	ApprovalAssignedToID pgtype.Int4      `json:"approval_assigned_to_id"`
	IsActive             bool             `json:"is_active"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
}

// List resources with filtering and pagination
func (q *Queries) ListResources(ctx context.Context, arg ListResourcesParams) ([]ListResourcesRow, error) {
	rows, err := q.db.Query(ctx, listResources,
		arg.OrganizationID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResourcesRow{}
	for rows.Next() {
		var i ListResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNumber,
			&i.Title,
			&i.Description,
			&i.StatusID,
			&i.FileID,
			&i.Confidence,
			&i.OrganizationID,
			&i.CreatedByAccountID,
			&i.ApprovalStatus,
			&i.ApprovalAssignedToID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchResourcesByText = `-- name: SearchResourcesByText :many

SELECT
    id, resource_number, title, description, status_id,
    confidence, created_at, updated_at,
    ts_rank(to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, '')), to_tsquery('english', $2)) AS rank
FROM example_resources
WHERE organization_id = $1
    AND is_active = true
    AND to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, '')) @@ to_tsquery('english', $2)
ORDER BY rank DESC, created_at DESC
LIMIT $3 OFFSET $4
`

type SearchResourcesByTextParams struct {
	OrganizationID int32  `json:"organization_id"`
	ToTsquery      string `json:"to_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type SearchResourcesByTextRow struct {
	ID             int32            `json:"id"`
	ResourceNumber string           `json:"resource_number"`
	Title          string           `json:"title"`
	Description    pgtype.Text      `json:"description"`
	StatusID       int16            `json:"status_id"`
	Confidence     pgtype.Numeric   `json:"confidence"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Rank           float32          `json:"rank"`
}

// SEARCH operations
// Full-text search on title and description
func (q *Queries) SearchResourcesByText(ctx context.Context, arg SearchResourcesByTextParams) ([]SearchResourcesByTextRow, error) {
	rows, err := q.db.Query(ctx, searchResourcesByText,
		arg.OrganizationID,
		arg.ToTsquery,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchResourcesByTextRow{}
	for rows.Next() {
		var i SearchResourcesByTextRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNumber,
			&i.Title,
			&i.Description,
			&i.StatusID,
			&i.Confidence,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResource = `-- name: UpdateResource :exec

UPDATE example_resources SET
    title = COALESCE($1, title),
    description = COALESCE($2, description),
    status_id = COALESCE($3, status_id),
    metadata = COALESCE($4, metadata),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5 AND organization_id = $6 AND is_active = true
`

type UpdateResourceParams struct {
	Title          pgtype.Text `json:"title"`
	Description    pgtype.Text `json:"description"`
	StatusID       pgtype.Int2 `json:"status_id"`
	Metadata       []byte      `json:"metadata"`
	ID             int32       `json:"id"`
	OrganizationID int32       `json:"organization_id"`
}

// UPDATE operations
func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) error {
	_, err := q.db.Exec(ctx, updateResource,
		arg.Title,
		arg.Description,
		arg.StatusID,
		arg.Metadata,
		arg.ID,
		arg.OrganizationID,
	)
	return err
}

const updateResourceApprovalStatus = `-- name: UpdateResourceApprovalStatus :exec
UPDATE example_resources SET
    approval_status = $3,
    approval_action_taker_id = $4,
    approval_notes = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND organization_id = $2 AND is_active = true
`

type UpdateResourceApprovalStatusParams struct {
	ID                    int32       `json:"id"`
	OrganizationID        int32       `json:"organization_id"`
	ApprovalStatus        pgtype.Text `json:"approval_status"`
	ApprovalActionTakerID pgtype.Int4 `json:"approval_action_taker_id"`
	ApprovalNotes         pgtype.Text `json:"approval_notes"`
}

// Update approval workflow status
func (q *Queries) UpdateResourceApprovalStatus(ctx context.Context, arg UpdateResourceApprovalStatusParams) error {
	_, err := q.db.Exec(ctx, updateResourceApprovalStatus,
		arg.ID,
		arg.OrganizationID,
		arg.ApprovalStatus,
		arg.ApprovalActionTakerID,
		arg.ApprovalNotes,
	)
	return err
}

const updateResourceProcessingData = `-- name: UpdateResourceProcessingData :exec
UPDATE example_resources SET
    extracted_data = COALESCE($1, extracted_data),
    processed_data = COALESCE($2, processed_data),
    confidence = COALESCE($3, confidence),
    status_id = COALESCE($4, status_id),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5 AND organization_id = $6
`

type UpdateResourceProcessingDataParams struct {
	ExtractedData  []byte         `json:"extracted_data"`
	ProcessedData  []byte         `json:"processed_data"`
	Confidence     pgtype.Numeric `json:"confidence"`
	StatusID       pgtype.Int2    `json:"status_id"`
	ID             int32          `json:"id"`
	OrganizationID int32          `json:"organization_id"`
}

// Update OCR/LLM processing results
func (q *Queries) UpdateResourceProcessingData(ctx context.Context, arg UpdateResourceProcessingDataParams) error {
	_, err := q.db.Exec(ctx, updateResourceProcessingData,
		arg.ExtractedData,
		arg.ProcessedData,
		arg.Confidence,
		arg.StatusID,
		arg.ID,
		arg.OrganizationID,
	)
	return err
}

const updateResourceStatus = `-- name: UpdateResourceStatus :exec
UPDATE example_resources SET
    status_id = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND organization_id = $2 AND is_active = true
`

type UpdateResourceStatusParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
	StatusID       int16 `json:"status_id"`
}

func (q *Queries) UpdateResourceStatus(ctx context.Context, arg UpdateResourceStatusParams) error {
	_, err := q.db.Exec(ctx, updateResourceStatus, arg.ID, arg.OrganizationID, arg.StatusID)
	return err
}
