// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: files.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFileAsset = `-- name: CreateFileAsset :one
INSERT INTO files.file_assets (
    file_name,
    original_file_name,
    storage_path,
    bucket_name,
    file_size,
    mime_type,
    file_category_id,
    file_context_id,
    is_public,
    entity_type,
    entity_id,
    purpose,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, file_name, original_file_name, storage_path, bucket_name, file_size, mime_type, file_category_id, file_context_id, is_public, entity_type, entity_id, purpose, metadata, created_at, updated_at
`

type CreateFileAssetParams struct {
	FileName         string      `json:"file_name"`
	OriginalFileName string      `json:"original_file_name"`
	StoragePath      string      `json:"storage_path"`
	BucketName       string      `json:"bucket_name"`
	FileSize         int64       `json:"file_size"`
	MimeType         string      `json:"mime_type"`
	FileCategoryID   int16       `json:"file_category_id"`
	FileContextID    int16       `json:"file_context_id"`
	IsPublic         pgtype.Bool `json:"is_public"`
	EntityType       pgtype.Text `json:"entity_type"`
	EntityID         pgtype.Int4 `json:"entity_id"`
	Purpose          pgtype.Text `json:"purpose"`
	Metadata         []byte      `json:"metadata"`
}

func (q *Queries) CreateFileAsset(ctx context.Context, arg CreateFileAssetParams) (FileManagerFileAsset, error) {
	row := q.db.QueryRow(ctx, createFileAsset,
		arg.FileName,
		arg.OriginalFileName,
		arg.StoragePath,
		arg.BucketName,
		arg.FileSize,
		arg.MimeType,
		arg.FileCategoryID,
		arg.FileContextID,
		arg.IsPublic,
		arg.EntityType,
		arg.EntityID,
		arg.Purpose,
		arg.Metadata,
	)
	var i FileManagerFileAsset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalFileName,
		&i.StoragePath,
		&i.BucketName,
		&i.FileSize,
		&i.MimeType,
		&i.FileCategoryID,
		&i.FileContextID,
		&i.IsPublic,
		&i.EntityType,
		&i.EntityID,
		&i.Purpose,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFileAsset = `-- name: DeleteFileAsset :exec
DELETE FROM files.file_assets
WHERE id = $1
`

func (q *Queries) DeleteFileAsset(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFileAsset, id)
	return err
}

const getFileAssetByID = `-- name: GetFileAssetByID :one
SELECT id, file_name, original_file_name, storage_path, bucket_name, file_size, mime_type, file_category_id, file_context_id, is_public, entity_type, entity_id, purpose, metadata, created_at, updated_at FROM files.file_assets
WHERE id = $1
`

func (q *Queries) GetFileAssetByID(ctx context.Context, id int32) (FileManagerFileAsset, error) {
	row := q.db.QueryRow(ctx, getFileAssetByID, id)
	var i FileManagerFileAsset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalFileName,
		&i.StoragePath,
		&i.BucketName,
		&i.FileSize,
		&i.MimeType,
		&i.FileCategoryID,
		&i.FileContextID,
		&i.IsPublic,
		&i.EntityType,
		&i.EntityID,
		&i.Purpose,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileAssetByStoragePath = `-- name: GetFileAssetByStoragePath :one
SELECT id, file_name, original_file_name, storage_path, bucket_name, file_size, mime_type, file_category_id, file_context_id, is_public, entity_type, entity_id, purpose, metadata, created_at, updated_at FROM files.file_assets
WHERE storage_path = $1
`

func (q *Queries) GetFileAssetByStoragePath(ctx context.Context, storagePath string) (FileManagerFileAsset, error) {
	row := q.db.QueryRow(ctx, getFileAssetByStoragePath, storagePath)
	var i FileManagerFileAsset
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.OriginalFileName,
		&i.StoragePath,
		&i.BucketName,
		&i.FileSize,
		&i.MimeType,
		&i.FileCategoryID,
		&i.FileContextID,
		&i.IsPublic,
		&i.EntityType,
		&i.EntityID,
		&i.Purpose,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileAssetsByCategory = `-- name: GetFileAssetsByCategory :many
SELECT fa.id, fa.file_name, fa.original_file_name, fa.storage_path, fa.bucket_name, fa.file_size, fa.mime_type, fa.file_category_id, fa.file_context_id, fa.is_public, fa.entity_type, fa.entity_id, fa.purpose, fa.metadata, fa.created_at, fa.updated_at, fc.name as category_name
FROM files.file_assets fa
JOIN files.file_categories fc ON fa.file_category_id = fc.id  
WHERE fc.name = $1
ORDER BY fa.created_at DESC
`

type GetFileAssetsByCategoryRow struct {
	ID               int32              `json:"id"`
	FileName         string             `json:"file_name"`
	OriginalFileName string             `json:"original_file_name"`
	StoragePath      string             `json:"storage_path"`
	BucketName       string             `json:"bucket_name"`
	FileSize         int64              `json:"file_size"`
	MimeType         string             `json:"mime_type"`
	FileCategoryID   int16              `json:"file_category_id"`
	FileContextID    int16              `json:"file_context_id"`
	IsPublic         pgtype.Bool        `json:"is_public"`
	EntityType       pgtype.Text        `json:"entity_type"`
	EntityID         pgtype.Int4        `json:"entity_id"`
	Purpose          pgtype.Text        `json:"purpose"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	CategoryName     string             `json:"category_name"`
}

func (q *Queries) GetFileAssetsByCategory(ctx context.Context, name string) ([]GetFileAssetsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getFileAssetsByCategory, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileAssetsByCategoryRow{}
	for rows.Next() {
		var i GetFileAssetsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalFileName,
			&i.StoragePath,
			&i.BucketName,
			&i.FileSize,
			&i.MimeType,
			&i.FileCategoryID,
			&i.FileContextID,
			&i.IsPublic,
			&i.EntityType,
			&i.EntityID,
			&i.Purpose,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileAssetsByContext = `-- name: GetFileAssetsByContext :many
SELECT fa.id, fa.file_name, fa.original_file_name, fa.storage_path, fa.bucket_name, fa.file_size, fa.mime_type, fa.file_category_id, fa.file_context_id, fa.is_public, fa.entity_type, fa.entity_id, fa.purpose, fa.metadata, fa.created_at, fa.updated_at, fctx.name as context_name
FROM files.file_assets fa
JOIN files.file_contexts fctx ON fa.file_context_id = fctx.id
WHERE fctx.name = $1
ORDER BY fa.created_at DESC
`

type GetFileAssetsByContextRow struct {
	ID               int32              `json:"id"`
	FileName         string             `json:"file_name"`
	OriginalFileName string             `json:"original_file_name"`
	StoragePath      string             `json:"storage_path"`
	BucketName       string             `json:"bucket_name"`
	FileSize         int64              `json:"file_size"`
	MimeType         string             `json:"mime_type"`
	FileCategoryID   int16              `json:"file_category_id"`
	FileContextID    int16              `json:"file_context_id"`
	IsPublic         pgtype.Bool        `json:"is_public"`
	EntityType       pgtype.Text        `json:"entity_type"`
	EntityID         pgtype.Int4        `json:"entity_id"`
	Purpose          pgtype.Text        `json:"purpose"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ContextName      string             `json:"context_name"`
}

func (q *Queries) GetFileAssetsByContext(ctx context.Context, name string) ([]GetFileAssetsByContextRow, error) {
	rows, err := q.db.Query(ctx, getFileAssetsByContext, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileAssetsByContextRow{}
	for rows.Next() {
		var i GetFileAssetsByContextRow
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalFileName,
			&i.StoragePath,
			&i.BucketName,
			&i.FileSize,
			&i.MimeType,
			&i.FileCategoryID,
			&i.FileContextID,
			&i.IsPublic,
			&i.EntityType,
			&i.EntityID,
			&i.Purpose,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ContextName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileAssetsByEntity = `-- name: GetFileAssetsByEntity :many
SELECT id, file_name, original_file_name, storage_path, bucket_name, file_size, mime_type, file_category_id, file_context_id, is_public, entity_type, entity_id, purpose, metadata, created_at, updated_at FROM files.file_assets
WHERE entity_type = $1 AND entity_id = $2
`

type GetFileAssetsByEntityParams struct {
	EntityType pgtype.Text `json:"entity_type"`
	EntityID   pgtype.Int4 `json:"entity_id"`
}

func (q *Queries) GetFileAssetsByEntity(ctx context.Context, arg GetFileAssetsByEntityParams) ([]FileManagerFileAsset, error) {
	rows, err := q.db.Query(ctx, getFileAssetsByEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileManagerFileAsset{}
	for rows.Next() {
		var i FileManagerFileAsset
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalFileName,
			&i.StoragePath,
			&i.BucketName,
			&i.FileSize,
			&i.MimeType,
			&i.FileCategoryID,
			&i.FileContextID,
			&i.IsPublic,
			&i.EntityType,
			&i.EntityID,
			&i.Purpose,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileAssetsByEntityAndPurpose = `-- name: GetFileAssetsByEntityAndPurpose :many
SELECT id, file_name, original_file_name, storage_path, bucket_name, file_size, mime_type, file_category_id, file_context_id, is_public, entity_type, entity_id, purpose, metadata, created_at, updated_at FROM files.file_assets
WHERE entity_type = $1 AND entity_id = $2 AND purpose = $3
ORDER BY created_at DESC
`

type GetFileAssetsByEntityAndPurposeParams struct {
	EntityType pgtype.Text `json:"entity_type"`
	EntityID   pgtype.Int4 `json:"entity_id"`
	Purpose    pgtype.Text `json:"purpose"`
}

func (q *Queries) GetFileAssetsByEntityAndPurpose(ctx context.Context, arg GetFileAssetsByEntityAndPurposeParams) ([]FileManagerFileAsset, error) {
	rows, err := q.db.Query(ctx, getFileAssetsByEntityAndPurpose, arg.EntityType, arg.EntityID, arg.Purpose)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileManagerFileAsset{}
	for rows.Next() {
		var i FileManagerFileAsset
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalFileName,
			&i.StoragePath,
			&i.BucketName,
			&i.FileSize,
			&i.MimeType,
			&i.FileCategoryID,
			&i.FileContextID,
			&i.IsPublic,
			&i.EntityType,
			&i.EntityID,
			&i.Purpose,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileCategories = `-- name: GetFileCategories :many
SELECT id, name, max_size_bytes FROM files.file_categories ORDER BY name
`

func (q *Queries) GetFileCategories(ctx context.Context) ([]FileManagerFileCategory, error) {
	rows, err := q.db.Query(ctx, getFileCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileManagerFileCategory{}
	for rows.Next() {
		var i FileManagerFileCategory
		if err := rows.Scan(&i.ID, &i.Name, &i.MaxSizeBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileContexts = `-- name: GetFileContexts :many
SELECT id, name FROM files.file_contexts ORDER BY name
`

func (q *Queries) GetFileContexts(ctx context.Context) ([]FileManagerFileContext, error) {
	rows, err := q.db.Query(ctx, getFileContexts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileManagerFileContext{}
	for rows.Next() {
		var i FileManagerFileContext
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFileAssets = `-- name: ListFileAssets :many
SELECT fa.id, fa.file_name, fa.original_file_name, fa.storage_path, fa.bucket_name, fa.file_size, fa.mime_type, fa.file_category_id, fa.file_context_id, fa.is_public, fa.entity_type, fa.entity_id, fa.purpose, fa.metadata, fa.created_at, fa.updated_at, fc.name as category_name, fctx.name as context_name
FROM files.file_assets fa
JOIN files.file_categories fc ON fa.file_category_id = fc.id
JOIN files.file_contexts fctx ON fa.file_context_id = fctx.id
ORDER BY fa.created_at DESC
LIMIT $1 OFFSET $2
`

type ListFileAssetsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFileAssetsRow struct {
	ID               int32              `json:"id"`
	FileName         string             `json:"file_name"`
	OriginalFileName string             `json:"original_file_name"`
	StoragePath      string             `json:"storage_path"`
	BucketName       string             `json:"bucket_name"`
	FileSize         int64              `json:"file_size"`
	MimeType         string             `json:"mime_type"`
	FileCategoryID   int16              `json:"file_category_id"`
	FileContextID    int16              `json:"file_context_id"`
	IsPublic         pgtype.Bool        `json:"is_public"`
	EntityType       pgtype.Text        `json:"entity_type"`
	EntityID         pgtype.Int4        `json:"entity_id"`
	Purpose          pgtype.Text        `json:"purpose"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	CategoryName     string             `json:"category_name"`
	ContextName      string             `json:"context_name"`
}

func (q *Queries) ListFileAssets(ctx context.Context, arg ListFileAssetsParams) ([]ListFileAssetsRow, error) {
	rows, err := q.db.Query(ctx, listFileAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFileAssetsRow{}
	for rows.Next() {
		var i ListFileAssetsRow
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.OriginalFileName,
			&i.StoragePath,
			&i.BucketName,
			&i.FileSize,
			&i.MimeType,
			&i.FileCategoryID,
			&i.FileContextID,
			&i.IsPublic,
			&i.EntityType,
			&i.EntityID,
			&i.Purpose,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.ContextName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileAsset = `-- name: UpdateFileAsset :exec
UPDATE files.file_assets
SET 
    file_name = $2,
    storage_path = $3,
    purpose = $4,
    metadata = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateFileAssetParams struct {
	ID          int32       `json:"id"`
	FileName    string      `json:"file_name"`
	StoragePath string      `json:"storage_path"`
	Purpose     pgtype.Text `json:"purpose"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) UpdateFileAsset(ctx context.Context, arg UpdateFileAssetParams) error {
	_, err := q.db.Exec(ctx, updateFileAsset,
		arg.ID,
		arg.FileName,
		arg.StoragePath,
		arg.Purpose,
		arg.Metadata,
	)
	return err
}
