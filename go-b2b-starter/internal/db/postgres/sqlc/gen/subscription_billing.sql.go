// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: subscription_billing.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const decrementInvoiceCount = `-- name: DecrementInvoiceCount :one
UPDATE subscription_billing.quota_tracking
SET
    invoice_count = invoice_count - 1,
    updated_at = CURRENT_TIMESTAMP
WHERE organization_id = $1
RETURNING id, organization_id, max_seats, period_start, period_end, last_synced_at, created_at, updated_at, invoice_count
`

// Decrement invoice count by 1 (called after successful invoice processing)
func (q *Queries) DecrementInvoiceCount(ctx context.Context, organizationID int32) (SubscriptionBillingQuotaTracking, error) {
	row := q.db.QueryRow(ctx, decrementInvoiceCount, organizationID)
	var i SubscriptionBillingQuotaTracking
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.MaxSeats,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvoiceCount,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscription_billing.subscriptions
WHERE organization_id = $1
`

// Delete subscription (when subscription is permanently deleted)
func (q *Queries) DeleteSubscription(ctx context.Context, organizationID int32) error {
	_, err := q.db.Exec(ctx, deleteSubscription, organizationID)
	return err
}

const getQuotaByOrgID = `-- name: GetQuotaByOrgID :one
SELECT id, organization_id, max_seats, period_start, period_end, last_synced_at, created_at, updated_at, invoice_count FROM subscription_billing.quota_tracking
WHERE organization_id = $1
LIMIT 1
`

// Get quota tracking for an organization
func (q *Queries) GetQuotaByOrgID(ctx context.Context, organizationID int32) (SubscriptionBillingQuotaTracking, error) {
	row := q.db.QueryRow(ctx, getQuotaByOrgID, organizationID)
	var i SubscriptionBillingQuotaTracking
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.MaxSeats,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvoiceCount,
	)
	return i, err
}

const getQuotaStatus = `-- name: GetQuotaStatus :one
SELECT
    s.subscription_status,
    s.current_period_start,
    s.current_period_end,
    s.cancel_at_period_end,
    q.invoice_count,
    q.max_seats,
    CASE
        WHEN s.subscription_status = 'active' AND q.invoice_count > 0
        THEN TRUE
        ELSE FALSE
    END AS can_process_invoice
FROM subscription_billing.subscriptions s
INNER JOIN subscription_billing.quota_tracking q ON s.organization_id = q.organization_id
WHERE s.organization_id = $1
LIMIT 1
`

type GetQuotaStatusRow struct {
	SubscriptionStatus string           `json:"subscription_status"`
	CurrentPeriodStart pgtype.Timestamp `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamp `json:"current_period_end"`
	CancelAtPeriodEnd  pgtype.Bool      `json:"cancel_at_period_end"`
	InvoiceCount       int32            `json:"invoice_count"`
	MaxSeats           pgtype.Int4      `json:"max_seats"`
	CanProcessInvoice  bool             `json:"can_process_invoice"`
}

// Get combined subscription and quota status for fast quota checks
func (q *Queries) GetQuotaStatus(ctx context.Context, organizationID int32) (GetQuotaStatusRow, error) {
	row := q.db.QueryRow(ctx, getQuotaStatus, organizationID)
	var i GetQuotaStatusRow
	err := row.Scan(
		&i.SubscriptionStatus,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.InvoiceCount,
		&i.MaxSeats,
		&i.CanProcessInvoice,
	)
	return i, err
}

const getSubscriptionByOrgID = `-- name: GetSubscriptionByOrgID :one
SELECT id, organization_id, external_customer_id, subscription_id, subscription_status, product_id, product_name, plan_name, current_period_start, current_period_end, cancel_at_period_end, canceled_at, created_at, updated_at, metadata FROM subscription_billing.subscriptions
WHERE organization_id = $1
LIMIT 1
`

// Get subscription details for an organization
func (q *Queries) GetSubscriptionByOrgID(ctx context.Context, organizationID int32) (SubscriptionBillingSubscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByOrgID, organizationID)
	var i SubscriptionBillingSubscription
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ExternalCustomerID,
		&i.SubscriptionID,
		&i.SubscriptionStatus,
		&i.ProductID,
		&i.ProductName,
		&i.PlanName,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const getSubscriptionBySubscriptionID = `-- name: GetSubscriptionBySubscriptionID :one
SELECT id, organization_id, external_customer_id, subscription_id, subscription_status, product_id, product_name, plan_name, current_period_start, current_period_end, cancel_at_period_end, canceled_at, created_at, updated_at, metadata FROM subscription_billing.subscriptions
WHERE subscription_id = $1
LIMIT 1
`

// Get subscription by Polar subscription ID
func (q *Queries) GetSubscriptionBySubscriptionID(ctx context.Context, subscriptionID string) (SubscriptionBillingSubscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionBySubscriptionID, subscriptionID)
	var i SubscriptionBillingSubscription
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ExternalCustomerID,
		&i.SubscriptionID,
		&i.SubscriptionStatus,
		&i.ProductID,
		&i.ProductName,
		&i.PlanName,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}

const listActiveSubscriptions = `-- name: ListActiveSubscriptions :many
SELECT id, organization_id, external_customer_id, subscription_id, subscription_status, product_id, product_name, plan_name, current_period_start, current_period_end, cancel_at_period_end, canceled_at, created_at, updated_at, metadata FROM subscription_billing.subscriptions
WHERE subscription_status = 'active'
ORDER BY created_at DESC
`

// List all active subscriptions for monitoring/admin purposes
func (q *Queries) ListActiveSubscriptions(ctx context.Context) ([]SubscriptionBillingSubscription, error) {
	rows, err := q.db.Query(ctx, listActiveSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubscriptionBillingSubscription{}
	for rows.Next() {
		var i SubscriptionBillingSubscription
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.ExternalCustomerID,
			&i.SubscriptionID,
			&i.SubscriptionStatus,
			&i.ProductID,
			&i.ProductName,
			&i.PlanName,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAtPeriodEnd,
			&i.CanceledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotasNearLimit = `-- name: ListQuotasNearLimit :many
SELECT
    q.id, q.organization_id, q.max_seats, q.period_start, q.period_end, q.last_synced_at, q.created_at, q.updated_at, q.invoice_count,
    s.subscription_status,
    s.product_name
FROM subscription_billing.quota_tracking q
INNER JOIN subscription_billing.subscriptions s ON q.organization_id = s.organization_id
WHERE
    s.subscription_status = 'active'
    AND q.invoice_count <= $1
ORDER BY q.invoice_count ASC
`

type ListQuotasNearLimitRow struct {
	ID                 int32            `json:"id"`
	OrganizationID     int32            `json:"organization_id"`
	MaxSeats           pgtype.Int4      `json:"max_seats"`
	PeriodStart        pgtype.Timestamp `json:"period_start"`
	PeriodEnd          pgtype.Timestamp `json:"period_end"`
	LastSyncedAt       pgtype.Timestamp `json:"last_synced_at"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	InvoiceCount       int32            `json:"invoice_count"`
	SubscriptionStatus string           `json:"subscription_status"`
	ProductName        pgtype.Text      `json:"product_name"`
}

// List organizations approaching their quota limit (for alerting)
func (q *Queries) ListQuotasNearLimit(ctx context.Context, invoiceCount int32) ([]ListQuotasNearLimitRow, error) {
	rows, err := q.db.Query(ctx, listQuotasNearLimit, invoiceCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuotasNearLimitRow{}
	for rows.Next() {
		var i ListQuotasNearLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.MaxSeats,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.LastSyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InvoiceCount,
			&i.SubscriptionStatus,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetQuotaForPeriod = `-- name: ResetQuotaForPeriod :one
UPDATE subscription_billing.quota_tracking
SET
    invoice_count = $2,
    period_start = $3,
    period_end = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE organization_id = $1
RETURNING id, organization_id, max_seats, period_start, period_end, last_synced_at, created_at, updated_at, invoice_count
`

type ResetQuotaForPeriodParams struct {
	OrganizationID int32            `json:"organization_id"`
	InvoiceCount   int32            `json:"invoice_count"`
	PeriodStart    pgtype.Timestamp `json:"period_start"`
	PeriodEnd      pgtype.Timestamp `json:"period_end"`
}

// Reset quota counters for a new billing period
func (q *Queries) ResetQuotaForPeriod(ctx context.Context, arg ResetQuotaForPeriodParams) (SubscriptionBillingQuotaTracking, error) {
	row := q.db.QueryRow(ctx, resetQuotaForPeriod,
		arg.OrganizationID,
		arg.InvoiceCount,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	var i SubscriptionBillingQuotaTracking
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.MaxSeats,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvoiceCount,
	)
	return i, err
}

const upsertQuota = `-- name: UpsertQuota :one
INSERT INTO subscription_billing.quota_tracking (
    organization_id,
    invoice_count,
    max_seats,
    period_start,
    period_end,
    last_synced_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
ON CONFLICT (organization_id)
DO UPDATE SET
    invoice_count = EXCLUDED.invoice_count,
    max_seats = EXCLUDED.max_seats,
    period_start = EXCLUDED.period_start,
    period_end = EXCLUDED.period_end,
    last_synced_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, organization_id, max_seats, period_start, period_end, last_synced_at, created_at, updated_at, invoice_count
`

type UpsertQuotaParams struct {
	OrganizationID int32            `json:"organization_id"`
	InvoiceCount   int32            `json:"invoice_count"`
	MaxSeats       pgtype.Int4      `json:"max_seats"`
	PeriodStart    pgtype.Timestamp `json:"period_start"`
	PeriodEnd      pgtype.Timestamp `json:"period_end"`
}

// Create or update quota tracking
func (q *Queries) UpsertQuota(ctx context.Context, arg UpsertQuotaParams) (SubscriptionBillingQuotaTracking, error) {
	row := q.db.QueryRow(ctx, upsertQuota,
		arg.OrganizationID,
		arg.InvoiceCount,
		arg.MaxSeats,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	var i SubscriptionBillingQuotaTracking
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.MaxSeats,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.LastSyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvoiceCount,
	)
	return i, err
}

const upsertSubscription = `-- name: UpsertSubscription :one
INSERT INTO subscription_billing.subscriptions (
    organization_id,
    external_customer_id,
    subscription_id,
    subscription_status,
    product_id,
    product_name,
    plan_name,
    current_period_start,
    current_period_end,
    cancel_at_period_end,
    canceled_at,
    metadata,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, CURRENT_TIMESTAMP
)
ON CONFLICT (organization_id)
DO UPDATE SET
    external_customer_id = EXCLUDED.external_customer_id,
    subscription_id = EXCLUDED.subscription_id,
    subscription_status = EXCLUDED.subscription_status,
    product_id = EXCLUDED.product_id,
    product_name = EXCLUDED.product_name,
    plan_name = EXCLUDED.plan_name,
    current_period_start = EXCLUDED.current_period_start,
    current_period_end = EXCLUDED.current_period_end,
    cancel_at_period_end = EXCLUDED.cancel_at_period_end,
    canceled_at = EXCLUDED.canceled_at,
    metadata = EXCLUDED.metadata,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, organization_id, external_customer_id, subscription_id, subscription_status, product_id, product_name, plan_name, current_period_start, current_period_end, cancel_at_period_end, canceled_at, created_at, updated_at, metadata
`

type UpsertSubscriptionParams struct {
	OrganizationID     int32            `json:"organization_id"`
	ExternalCustomerID string           `json:"external_customer_id"`
	SubscriptionID     string           `json:"subscription_id"`
	SubscriptionStatus string           `json:"subscription_status"`
	ProductID          string           `json:"product_id"`
	ProductName        pgtype.Text      `json:"product_name"`
	PlanName           pgtype.Text      `json:"plan_name"`
	CurrentPeriodStart pgtype.Timestamp `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamp `json:"current_period_end"`
	CancelAtPeriodEnd  pgtype.Bool      `json:"cancel_at_period_end"`
	CanceledAt         pgtype.Timestamp `json:"canceled_at"`
	Metadata           []byte           `json:"metadata"`
}

// Create or update subscription from Polar webhook
func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) (SubscriptionBillingSubscription, error) {
	row := q.db.QueryRow(ctx, upsertSubscription,
		arg.OrganizationID,
		arg.ExternalCustomerID,
		arg.SubscriptionID,
		arg.SubscriptionStatus,
		arg.ProductID,
		arg.ProductName,
		arg.PlanName,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAtPeriodEnd,
		arg.CanceledAt,
		arg.Metadata,
	)
	var i SubscriptionBillingSubscription
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.ExternalCustomerID,
		&i.SubscriptionID,
		&i.SubscriptionStatus,
		&i.ProductID,
		&i.ProductName,
		&i.PlanName,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAtPeriodEnd,
		&i.CanceledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Metadata,
	)
	return i, err
}
