// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: documents.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDocumentsByOrganization = `-- name: CountDocumentsByOrganization :one
SELECT COUNT(*) FROM documents.documents
WHERE organization_id = $1
`

func (q *Queries) CountDocumentsByOrganization(ctx context.Context, organizationID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countDocumentsByOrganization, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDocumentsByStatus = `-- name: CountDocumentsByStatus :one
SELECT COUNT(*) FROM documents.documents
WHERE organization_id = $1 AND status = $2
`

type CountDocumentsByStatusParams struct {
	OrganizationID int32  `json:"organization_id"`
	Status         string `json:"status"`
}

func (q *Queries) CountDocumentsByStatus(ctx context.Context, arg CountDocumentsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDocumentsByStatus, arg.OrganizationID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDocument = `-- name: CreateDocument :one

INSERT INTO documents.documents (
    organization_id,
    file_asset_id,
    title,
    file_name,
    content_type,
    file_size,
    extracted_text,
    status,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at
`

type CreateDocumentParams struct {
	OrganizationID int32       `json:"organization_id"`
	FileAssetID    int32       `json:"file_asset_id"`
	Title          string      `json:"title"`
	FileName       string      `json:"file_name"`
	ContentType    string      `json:"content_type"`
	FileSize       int64       `json:"file_size"`
	ExtractedText  pgtype.Text `json:"extracted_text"`
	Status         string      `json:"status"`
	Metadata       []byte      `json:"metadata"`
}

// Documents queries
func (q *Queries) CreateDocument(ctx context.Context, arg CreateDocumentParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, createDocument,
		arg.OrganizationID,
		arg.FileAssetID,
		arg.Title,
		arg.FileName,
		arg.ContentType,
		arg.FileSize,
		arg.ExtractedText,
		arg.Status,
		arg.Metadata,
	)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents.documents
WHERE id = $1 AND organization_id = $2
`

type DeleteDocumentParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
}

func (q *Queries) DeleteDocument(ctx context.Context, arg DeleteDocumentParams) error {
	_, err := q.db.Exec(ctx, deleteDocument, arg.ID, arg.OrganizationID)
	return err
}

const getDocumentByFileAssetID = `-- name: GetDocumentByFileAssetID :one
SELECT id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at FROM documents.documents
WHERE file_asset_id = $1 AND organization_id = $2
`

type GetDocumentByFileAssetIDParams struct {
	FileAssetID    int32 `json:"file_asset_id"`
	OrganizationID int32 `json:"organization_id"`
}

func (q *Queries) GetDocumentByFileAssetID(ctx context.Context, arg GetDocumentByFileAssetIDParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, getDocumentByFileAssetID, arg.FileAssetID, arg.OrganizationID)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDocumentByID = `-- name: GetDocumentByID :one
SELECT id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at FROM documents.documents
WHERE id = $1 AND organization_id = $2
`

type GetDocumentByIDParams struct {
	ID             int32 `json:"id"`
	OrganizationID int32 `json:"organization_id"`
}

func (q *Queries) GetDocumentByID(ctx context.Context, arg GetDocumentByIDParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, getDocumentByID, arg.ID, arg.OrganizationID)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDocumentsByOrganization = `-- name: ListDocumentsByOrganization :many
SELECT id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at FROM documents.documents
WHERE organization_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDocumentsByOrganizationParams struct {
	OrganizationID int32 `json:"organization_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

func (q *Queries) ListDocumentsByOrganization(ctx context.Context, arg ListDocumentsByOrganizationParams) ([]DocumentsDocument, error) {
	rows, err := q.db.Query(ctx, listDocumentsByOrganization, arg.OrganizationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DocumentsDocument{}
	for rows.Next() {
		var i DocumentsDocument
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.FileAssetID,
			&i.Title,
			&i.FileName,
			&i.ContentType,
			&i.FileSize,
			&i.ExtractedText,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentsByStatus = `-- name: ListDocumentsByStatus :many
SELECT id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at FROM documents.documents
WHERE organization_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListDocumentsByStatusParams struct {
	OrganizationID int32  `json:"organization_id"`
	Status         string `json:"status"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) ListDocumentsByStatus(ctx context.Context, arg ListDocumentsByStatusParams) ([]DocumentsDocument, error) {
	rows, err := q.db.Query(ctx, listDocumentsByStatus,
		arg.OrganizationID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DocumentsDocument{}
	for rows.Next() {
		var i DocumentsDocument
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.FileAssetID,
			&i.Title,
			&i.FileName,
			&i.ContentType,
			&i.FileSize,
			&i.ExtractedText,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDocument = `-- name: UpdateDocument :one
UPDATE documents.documents
SET
    title = COALESCE($3, title),
    metadata = COALESCE($4, metadata),
    updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at
`

type UpdateDocumentParams struct {
	ID             int32  `json:"id"`
	OrganizationID int32  `json:"organization_id"`
	Title          string `json:"title"`
	Metadata       []byte `json:"metadata"`
}

func (q *Queries) UpdateDocument(ctx context.Context, arg UpdateDocumentParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, updateDocument,
		arg.ID,
		arg.OrganizationID,
		arg.Title,
		arg.Metadata,
	)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDocumentExtractedText = `-- name: UpdateDocumentExtractedText :one
UPDATE documents.documents
SET extracted_text = $3, status = 'processed', updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at
`

type UpdateDocumentExtractedTextParams struct {
	ID             int32       `json:"id"`
	OrganizationID int32       `json:"organization_id"`
	ExtractedText  pgtype.Text `json:"extracted_text"`
}

func (q *Queries) UpdateDocumentExtractedText(ctx context.Context, arg UpdateDocumentExtractedTextParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, updateDocumentExtractedText, arg.ID, arg.OrganizationID, arg.ExtractedText)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDocumentStatus = `-- name: UpdateDocumentStatus :one
UPDATE documents.documents
SET status = $3, updated_at = NOW()
WHERE id = $1 AND organization_id = $2
RETURNING id, organization_id, file_asset_id, title, file_name, content_type, file_size, extracted_text, status, metadata, created_at, updated_at
`

type UpdateDocumentStatusParams struct {
	ID             int32  `json:"id"`
	OrganizationID int32  `json:"organization_id"`
	Status         string `json:"status"`
}

func (q *Queries) UpdateDocumentStatus(ctx context.Context, arg UpdateDocumentStatusParams) (DocumentsDocument, error) {
	row := q.db.QueryRow(ctx, updateDocumentStatus, arg.ID, arg.OrganizationID, arg.Status)
	var i DocumentsDocument
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.FileAssetID,
		&i.Title,
		&i.FileName,
		&i.ContentType,
		&i.FileSize,
		&i.ExtractedText,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
